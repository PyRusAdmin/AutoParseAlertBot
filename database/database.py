# -*- coding: utf-8 -*-
import os
from datetime import datetime
import re
from peewee import SqliteDatabase, Model, IntegerField, CharField, AutoField, TextField, DateTimeField

db = SqliteDatabase('data/bot.db', timeout=30,
                    pragmas={'journal_mode': 'wal', 'cache_size': 4096, 'synchronous': 'NORMAL'})


class BaseModel(Model):
    class Meta:
        database = db


class User(BaseModel):
    """
    Модель для хранения основных данных пользователя Telegram.

    Используется для регистрации пользователей при первом запуске бота (/start)
    и хранения их профиля и языка интерфейса. Таблица общая для всех пользователей.

    Attributes:
        user_id (IntegerField): Уникальный идентификатор пользователя Telegram (первичный ключ).
        username (CharField, optional): Telegram-ник пользователя (может быть None).
        first_name (CharField, optional): Имя пользователя.
        last_name (CharField, optional): Фамилия пользователя.
        language (CharField): Язык интерфейса бота ('ru', 'en' или 'unset' при первом запуске).

    Meta:
        table_name (str): Имя таблицы в базе данных — 'user' (по умолчанию от имени класса).
    """
    user_id = IntegerField(unique=True)
    username = CharField(null=True)
    first_name = CharField(null=True)
    last_name = CharField(null=True)
    language = CharField(default="ru")  # "ru" или "en"


def create_groups_model(user_id):
    """
    Динамически создаёт модель Peewee для хранения чатов конкретного пользователя.

    Модель используется для отслеживания списка Telegram-групп и каналов, добавленных пользователем для мониторинга.
    Создаётся отдельная таблица для каждого пользователя по шаблону 'groups_<user_id>'.

    :param user_id: (int) Уникальный идентификатор пользователя Telegram.
    :return peewee.Model: Класс модели Peewee с полем `username_chat_channel`.

    Model Fields:
        username_chat_channel (CharField):
            Уникальное имя чата (канала) в формате @username или название.
    """

    class Groups(BaseModel):
        id = IntegerField(null=True)
        group_id = CharField(unique=True)
        group_hash = CharField(unique=True, index=True)
        name = CharField()
        username = CharField(null=True, unique=True)  # ← ДОБАВЛЕНО unique=True
        description = TextField(null=True)
        participants = IntegerField(default=0)
        category = CharField(null=True)
        group_type = CharField()
        link = CharField()
        date_added = DateTimeField(default=datetime.now)

        class Meta:
            table_name = f"{user_id}_groups"  # Имя таблицы

    return Groups  # Возвращаем класс модели


def create_keywords_model(user_id):
    """
    Динамически создаёт модель Peewee для хранения ключевых слов конкретного пользователя.

    Модель используется для отслеживания слов или фраз, по которым пользователь хочет фильтровать сообщения в группах.
    Создаётся отдельная таблица для каждого пользователя по шаблону 'keywords_<user_id>'.

    :param user_id: (int) Уникальный идентификатор пользователя Telegram.
    :return peewee.Model: Класс модели Peewee с полями `id` и `user_keyword`.

    Model Fields:
        id (AutoField):
            Автоинкрементный первичный ключ.
        user_keyword (CharField):
            Уникальное ключевое слово для поиска в сообщениях.
    """

    class Keywords(BaseModel):
        id = AutoField()  # <-- добавляем первичный ключ (иначе всё пишется в одну строку)
        user_keyword = CharField(unique=True)  # Поле для хранения ключевого слова

        class Meta:
            table_name = f"{user_id}_keywords"  # Имя таблицы

    return Keywords  # Возвращаем класс модели


def create_group_model(user_id):
    """
    Динамически создаёт модель Peewee для хранения технической группы пользователя.

    Модель используется для сохранения одного Telegram-чата (группы или канала),
    куда бот будет пересылать найденные сообщения, содержащие ключевые слова.
    Создаётся отдельная таблица для каждого пользователя по шаблону 'group_<user_id>'.

    :param user_id: (int) Уникальный идентификатор пользователя Telegram.
    :return peewee.Model: Класс модели Peewee с полями `id` и `user_group`.

    Model Fields:
        id (AutoField):
            Автоинкрементный первичный ключ.
        user_group (CharField):
            Уникальное имя технической группы (например, @my_alerts_channel).
    """

    class Group(BaseModel):
        id = AutoField()  # <-- добавляем первичный ключ (иначе всё пишется в одну строку)
        user_group = CharField(unique=True)  # Поле для хранения технической группы

        class Meta:
            table_name = f"{user_id}_group"  # Имя таблицы

    return Group  # Возвращаем класс модели


class TelegramGroup(BaseModel):
    """
    Модель для хранения данных о найденных Telegram-группах и каналах.

    Используется для централизованного хранения информации о группах,
    обнаруженных с помощью AI-поиска (через Groq). Позволяет избежать
    повторного поиска и дублирования. Таблица общая для всех пользователей.

    Attributes:
        group_hash (CharField): Уникальный хеш или ID группы, используется как ключ.
        name (CharField): Отображаемое название группы или канала.
        username (CharField, optional): Юзернейм (@username), может отсутствовать.
        description (TextField, optional): Описание группы из Telegram.
        participants (IntegerField): Количество участников, по умолчанию 0.
        category (CharField, optional): Категория, определённая ИИ (например, 'технологии').
        group_type (CharField): Тип чата — 'group', 'channel' или 'link'.
        link (CharField): Прямая ссылка на чат (https://t.me/...).
        date_added (DateTimeField): Дата и время добавления записи, по умолчанию — текущее время.

    Meta:
        table_name (str): Имя таблицы в базе данных — 'telegram_groups'.
    """
    id = IntegerField(null=True)  # Новое поле: Telegram entity ID

    group_hash = CharField(unique=True, index=True)  # ID группы или хеш username
    name = CharField()  # Название группы
    username = CharField(null=True)  # @username если есть
    description = TextField(null=True)  # Описание
    participants = IntegerField(default=0)  # Количество участников
    category = CharField(null=True)  # Категория (определяется AI)
    group_type = CharField()  # 'group', 'channel', 'link'
    link = CharField()  # Ссылка на группу
    date_added = DateTimeField(default=datetime.now)  # Дата добавления

    class Meta:
        table_name = 'telegram_groups'


def getting_number_records_database():
    """Получает количество записей в базе данных о найденных группах пользователями"""
    return TelegramGroup.select().count()


def get_target_group_count(user_id: int) -> int:
    """
    Получает количество технических групп (куда пересылаются уведомления),
    подключённых конкретным пользователем.

    Ищет записи в таблице `group_{user_id}`.

    :param user_id: (int) ID пользователя Telegram.
    :return int: Количество записей (обычно 0 или 1, так как группа одна).
    """
    GroupModel = create_group_model(user_id)

    # Убедимся, что таблица существует, иначе count() вызовет ошибку
    if not GroupModel.table_exists():
        return 0

    return GroupModel.select().count()


def get_session_count(user_id: int) -> int:
    """
    Подсчитывает количество .session файлов в папке accounts/{user_id}/.

    :param user_id: (int) ID пользователя Telegram.
    :return int: Количество .session файлов (0, если папка не существует или файлов нет).
    """
    session_dir = os.path.join("accounts", str(user_id))
    if not os.path.exists(session_dir):
        return 0

    session_files = [
        f for f in os.listdir(session_dir)
        if f.endswith(".session")
    ]
    return len(session_files)


def get_tracked_channels_count(user_id: int):
    """
    Получение количества подключенных групп для отслеживания ключевых слов

    :param user_id: (int) ID пользователя Telegram.
    :return int: Количество записей (обычно 0 или 1, так как группа одна).
    """
    GroupModel = create_groups_model(user_id)

    # Убедимся, что таблица существует, иначе count() вызовет ошибку
    if not GroupModel.table_exists():
        return 0

    return GroupModel.select().count()


def get_keywords_count(user_id: int):
    """
    Получение количества ключевых слов для отслеживания
    :param user_id:
    :return int: Количество записей (обычно 0 или 1, так как группа одна).
    """

    Keywords = create_keywords_model(user_id)

    # Убедимся, что таблица существует, иначе count() вызовет ошибку
    if not Keywords.table_exists():
        return 0

    return Keywords.select().count()
